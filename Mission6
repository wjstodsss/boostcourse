#include <stdio.h>

int a[201]; //입력된 높이들을 담을 그릇
int b[201]; //낙하거리를 계산한 값을 담을 그릇
int N;//가로길이 변수
int M;//세로길이 변수
int l;//for문에서 활용한 변수
int k=1;//입력된 높이 비교 변수
int sum;//높이가 같거나 큰 경우 누적합산
int bubble(int* x); 
int main(void){
    printf("\n version1.0");
    printf("\n [안녕하세요. 가장 큰 낙하거리 찾기 \"낙하사탕\"입니다.]\n");
    //방의 가로길이와 세로길이 입력
    re:
    printf("\n 방의 가로길이와 세로길이를 공백으로 구분하여 입력해 주세요(2~100) : ");
    scanf("%d %d",&N,&M);
    //방길이 유효성 검사 2<= N,M <=100 오류메시지 출력후 입력으로 회귀
    if(N<1 || N>101 || M<1 || M>101){
    printf("\n 2와 100사이의 정수를 공백으로 구분하여 입력해 주세요 ex) 10 10\n");
    goto re;
    }
    //상자들의 높이 입력(입력한 가로길이의 수만큼 높이를 같거나 다르게하여 입력)
    re1:
    printf("\n 상자들의 높이를 가로길이에 맞춰 공백으로 구분하여 입력해 주세요 : ");
    for(l=0;l<N;l++){//연산에서 무시되기는 하지만 입력길이를 막을 방법을 모르겠습니다. 
	scanf("%d",&a[l]);
    if(a[l]>M){
        printf("\n 상자들의 높이는 방의 세로길이 %d을(를) 초과 할 수 없습니다.\n",M);
        goto re1;
    }
	}
    /*연산의 시작입니다. 먼저 문제를 해석해보면 박스는 지면으로 부터 차곡차곡 쌓여 있고 방은 90도로 1회 회전합니다.
    예시를 통해 설명하면 높이가 7 4 2 0 0 6 0 7 0인 박스 중 90도 회전시 낙하거리가 가장 큰 박스는 방을 사각형의
    x축과 y축으로 볼때 x축      0 1 2 3 4 5 6 7 8이라고 할때 박스 장애물이 없는 경우 좌측 끝 0지점에 있는 박스라고 할 수 있습니다.
    다만 서로 높이가 상이 한 박스탑들이 중간에 있으므로 장애가 되는 박스의 개수 만큼 낙하거리는 감소 될 것입니다.
    장애가 되는 박스는 회전되기전 현재 상태의 우측의 박스들이며 장애 박스와 상관없이 시작점에 따라 최대 낙하거리가 변경되므로 
    전체 방의 가로길이(x축길이) 빼기 자신의 좌표(0~n) 빼기 장애박스의 수(자신의 높이와 같거나 높은 박스탑의 수)
    빼기 1(좌표를0에서시작하였으므로)*/
	for(l=0,sum=0;l<N;l++){//장애가되는 박스의 수를 구하기위한 반복문
		if(a[l]==0||l==N-1){//박스가 0개인 경우와 가로길이 가장 우측에 적재된 경우는 낙하거리가 없거나 0이므로 0으로 설정 
			b[l] = 0;
		}
		else{
			for(k=1;k<N;k++){//자신과 높이가 같거나 높은 박스탑을 찾아 누적 합산
				if(a[l]<=a[l+k]){
					sum++;
				}
			}
			b[l]=N-l-sum-1;//설정된 식으로 낙하거리를 구하여 배열b에 넣음 
			sum=0;//비교할 박스가 바뀌기 직전 마다 장애박스값을 0으로 초기화		
		}
	}
	*b=bubble(b);//버블 내림차순 정렬을 통해 b배열의 첫번째 주소에 가장 큰수를 배치함
	printf("\n 가장 큰 낙하 거리는 \"%d\"입니다.\n\n", b[0]);  //배치한 첫번째수를 출력 = 최대 낙하 거리 
    return 0;
}
int bubble(int* x){//버블정렬을 내림차순으로 하여 최대값을 구하였습니다. 
    int i, j, temp;
    for(i=0;i<N;i++){
        for(j=0;j<N-1-i;j++){
            if(x[j]<x[j+1]){
                temp = x[j];
                x[j] = x[j+1];
                x[j+1] = temp;
            }
        }
    }
    return *x;
} 

